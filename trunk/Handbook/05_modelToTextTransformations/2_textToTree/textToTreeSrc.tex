\newpage
\section{Text-to-Tree transformation}
\genHeader

Some sort of nice seque..

As we shall see in a moment, libraries and shelves correspond to a folder structure while the contents for a single dictionary are specified in a file.
Figure \ref{fig:moca-4-Tokens} depicts a small sample of the textual syntax used to specify a dictionary. 

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.7\textwidth]{4-tokens}
  \caption{Identified tokens in a dictionary file}
  \label{fig:moca-4-Tokens}
\end{center}
\end{figure}

On the way to an instance model of our dictionary metamodel, the very first step is to create nice \emph{chunks} of characters. This step is called
\emph{lexing} and it simplifies the actual comprehension of the complete text. Interestingly human beings actually comprehend text in a similar manner, one
recognizes whole words without ``seeing'' every individual character. This is the reason why you can siltl raed tihs sneentce alsomt eforftlsesly. A lexer
recognizes these chunks or \emph{tokens} and passes them on as a token stream to the \emph{parser} that does the actual work of recognizing complex
hierarchical and recursive structures.
   
To recognize the tokens as indicated in Fig.~\ref{fig:moca-4-Tokens}, \texttt{ANTLR} can automatically generate a lexer in Java from a compact specification.
This is actually a DSL for lexing and is explained in detail in \cite{ANTLR}. If you are unfamiliar with EBNF, and have feel you may have problems understanding
the lexer grammar, we suggest going through the documentation on on \url{www.antlr.org}, or reading the relevant chapters in \cite{ANTLR}. Otherwise, let's
complete the \emph{lexer} and \emph{parser} grammars that will handle our project instances.

\begin{itemize}
  
\item[$\blacktriangleright$] Navigate to ``Diction\-ary\-Code\-Adap\-ter/src/org.moflon.moca.dict\-ion\-ary\-.pars\-er" and edit \texttt{DictionaryLexer.g}
until it matches Fig.~\ref{eclipse:dictionaryLexer}. 


\newpage

\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=0.7\textwidth]{eclipse_dictionaryLexer}
  \caption{Lexer grammar}
  \label{eclipse:dictionaryLexer}
\end{center}
\end{figure}

\item[$\blacktriangleright$] Don't forget to add \texttt{import org.moflon.moca.MocaUtil} to \texttt{@header}, and be vigilant to avoid any typos and mistakes!

\item[$\blacktriangleright$] Save to compile the file, and ensure no errors persist before proceeding.

\end{itemize}

With this lexer, we can now form its stream of tokens into a \emph{tree}. In this context, a \emph{tree} is an acyclic, hierarchical, recursive structure (as
depicted in Fig.~\ref{eclipse:dictLexer}). Depending on what the tree is to be used for, it can be organized much differently with extra \emph{structural} nodes
such as \texttt{DICTIONARY} or \texttt{ENTRY} which were not present in the textual syntax. These can be used to give additional meaning to the tree.

\begin{figure}[htp]
\begin{center}
 \includegraphics[width=\textwidth]{5-tree}
  \caption{MocaTree structure}
  \label{eclipse:dictLexer}
\end{center}
\end{figure}

\begin{itemize}

\item[$\blacktriangleright$] Open and edit \texttt{DictionaryParser.g} (in the same package) until it matches Fig.~\ref{eclipse:dictParser}. As with
the lexer, avoid any mistakes, and ensure it compiles before proceeding.

\end{itemize}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.9\textwidth]{eclipse_dictionaryParser}
  \caption{Parser grammar}
  \label{eclipse:dictParser}
\end{center}
\end{figure}

\newpage

You'll notice that the parser grammar is extremely similar to the lexer grammar, save for some \emph{parser actions} following the \texttt{`->'} symbol. These
actions order the construction of the tree. Using this simple tree language, one can (1) abstract from tokens like \texttt{`\{'} or \texttt{`\}'}, which are
just \emph{syntactical noise}\footnote{Irrelevant content for our model.} and (2) enrich the tree with structural nodes like \texttt{ENTRY}, which add explicit
structure to the tree. Refer to \cite{ANTLR} and online resources for detailed explanations on the syntax and semantics of the parser grammar supported by
\texttt{ANTLR}.

\begin{itemize}


\item[$\blacktriangleright$] Before taking our lexer and parser out for a spin, navigate to ``src/org.moflon.tie" and open \texttt{TGGMain.java}. If everything
has gone well, it should resemble Fig.~\ref{eclipse:defaultTGGMain}.

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=\textwidth]{eclipse_TGGMainDefault}
  \caption{The TGG driver method}
  \label{eclipse:defaultTGGMain}
\end{center}
\end{figure}

\end{itemize}

You can see that this main method is essentially the driver for the transformation, executing each of the four stages of a full forward and backwards
transformation. In a nutshell, each folder in \texttt{instances/in/myLibrary} is taken as a root of a tree, and their folder and file structures are reflected
as a hierarchy of (children) nodes in the tree. For each file, the framework searches for a registered parser that is responsible for the particular file,
passes the content on to the parser and plugs in the tree from the parser as a single subtree of the corresponding file node in the overall tree.

\begin{itemize}

\item[$\blacktriangleright$] Comment out line 45, which calls the unparser to generate an output directory structure. We will define this model-to-text unparser
a bit later. 

\newpage

\item[$\blacktriangleright$] The final step is now to prepare some input for the framework. Navigate to ``DictionaryCodeAdapter/instances/in'' and create the
filesystem depicted in Fig.~\ref{eclipse:textDirectory}. 

\vspace{1cm}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=0.5\textwidth]{inputData}
  \caption{Input directory structure}
  \label{eclipse:textDirectory}
\end{center}
\end{figure}

\vspace{1cm}

\item[$\blacktriangleright$] Next, Complete each of the four \texttt{.dictionary} files with the contents in Table~\ref{moca-inputdata}.\footnote{Please do not
copy and paste this data as it your .pdf reader may add some invisible characters to the file that MOSL will not detect} Be sure that there are no mistakes with
elements such as colons or commas! Parsing will not succeed if the files do not perfectly conform to the lexer. 

\end{itemize}

As you can see, this input is structured as a single library split into two languages, each containing unique dictionaries. Reviewing
Fig.~\ref{eclipse:dictParser}, you can see that the structure of these files conform to the parser's \texttt{main} command: it first lists the dictionary's
\texttt{title}, may or may not contain a \texttt{author}, and contains all \texttt{entry} elements between a pair of \texttt{OPEN} and \texttt{CLOSE} brackets.

\newpage
\begin{table}

\begin{tabular}{p{6cm} p{6cm} }
\footnotesize
\textbf{english/numbers1-10.dictionary:}
\begin{verbatim}
title: "numbers1-10"
email: "contact@langenscheidt.de"	
{
  "null : zero", beginner
  "eins : one", beginner
  "zwei : two", beginner
  "drei : three", beginner
  "vier : four", beginner
  "fuenf : five", beginner
  "sechs : six", beginner
  "sieben : seven", beginner
  "acht : eight", beginner
  "neun : nine", beginner
  "zehn : ten", beginner 
}
\end{verbatim} 

\vspace{0.5cm}

\footnotesize
\textbf{french/numbers11-20.dictionary:}
\begin{verbatim}
title: "numbers11-20"
email: "contact@pons.de"	
{
  "elf : onze", advanced
  "zwoelf : douze", advanced
  "dreizehn : treize", advanced
  "vierzehn : quatorze", advanced
  "fuenfzehn : quinze", advanced
  "sechzehn : seize", master
  "siebzehn : dix-sept", master
  "achtzehn : dix-huit", master
  "neunzehn : dix-neuf", master
  "zwanzig : vingt", master
}
\end{verbatim}
&

\footnotesize
\textbf{french/numbers1-10.dictionary:}
\begin{verbatim}   
title: "numbers1-10"
email: "contact@pons.de"	
{
  "null : zero", beginner
  "eins : un/une", beginner
  "zwei : deux", beginner
  "drei : trois", beginner
  "vier : quatre", beginner
  "fuenf : cinq", beginner
  "sechs : six", beginner
  "sieben : sept", beginner
  "acht : huit", beginner
  "neun : neuf", beginner
  "zehn : dix", beginner 
}
\end{verbatim}

\vspace{0.5cm}

\footnotesize
\textbf{french/unknown.dictionary:}
\begin{verbatim}
title: "unknown"
{
	"unbekannt : unknown", beginner
}
\end{verbatim}
  \\
\end{tabular}   
\caption{Four input \texttt{.dictionary} files}
\label{moca-inputdata}

\end{table}
\clearpage

\begin{itemize} 

\item[$\blacktriangleright$] Once you have saved each file, right click on \texttt{TGGMain} and navigate to ``Run As/Java Application'' to run the
transformation.

\item[$\blacktriangleright$] Refresh the \texttt{instances} folder. Despite being (mostly) unimplemented, the TGG still executed, generating several files in
the process (Fig.~\ref{eclipse:postParse}).

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.4\textwidth]{eclipse_explorerPostGeneration}
  \caption{Result of the first TGG execution}
  \label{eclipse:postParse}
\end{center}
\end{figure} 

\end{itemize}

Let's go over what each of these files are. First, \texttt{tree.xmi} is the direct result of the \texttt{my\-Lib\-rary} filesystem input, which was parsed into
an \texttt{MocaTree} instance by ANTLR. 

While the parser is the only implemented piece of our transformation, TGGMain still used \texttt{tree.xmi} in a forward transformation, producing
the correspondence model \texttt{corrFWD.xmi} (which pairs with \texttt{protocol\_FWD.xmi}), and (empty) \texttt{Dictionary} target language result,
\texttt{tree.xmi\_FWD.xmi}.

\clearpage

The TGG also executed in the inverse direction; \texttt{tree.xmi\_FWD.xmi} was used next in the backwards direction, producing \texttt{corrBWD.xmi} (with
\texttt{proto\-col\-\_BWD\-.xmi}) and \texttt{tree.xmi\_FWD.xmi\_BWD.xmi}. We removed the command to do so, but ANTLR will later attempt to unparse this model,
which, if our TGG transformation was successful, will be identical to the input filesystem. In the meantime, we'll be able to compare this final tree to the original
\texttt{tree.xmi} to determine accuracy.

\begin{itemize}

\item[$\blacktriangleright$] Open \texttt{tree.xmi} and compare the contents to Fig.~\ref{eclipse:treeResult}. Reflect on the directory-type structure of the
tree, where each \texttt{File} and its contents appear as \texttt{Node}s. This file is important to understand -- The filesystem was transformed into a
corresponding hierarchy of \texttt{Folders} and \texttt{Files}. The actual \emph{text} content of each file is then transformed to a subtree using a registered,
suitable parser. The resulting subtree from the parser is then connected to the existing tree by setting its \texttt{DICTIONARY} root as the single child node
of a \texttt{File}.

\end{itemize}

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.6\textwidth]{eclipse_textParsingGeneration}
  \caption{MocaTree created by the framework using our parser}
  \label{eclipse:treeResult}
\end{center}
\end{figure}

\vspace{0.5cm}

If everything has executed without error, well done! Let's complete the forward direction (into a \texttt{Dictionary} instance) by specifiying some rules.
