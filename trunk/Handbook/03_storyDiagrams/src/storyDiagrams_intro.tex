\genHeader
\requiredTime{2 h}

Welcome to Part III, an introduction to unidirectional model transformations with programmed graph transformations via Story Driven Modeling (SDM).
SDMs focus on concrete implementations, so the plan is to implement each of the methods signatures declared in Part II with the abstract syntax. In other words,
this is where you'll complete your metamodel's dynamic semantics! Don't let the sheer size of this part frighten you off. We have included deep, thorough
explanations (with an ample number of figures) to ensure the concepts are crystal clear - it's really not that bad.

In Part II, we learned that we can implement methods in a fairly straightforward manner with injections and Java, so why bother with SDMs?

Overall, SDMs are a simpler, alternate way of developing methods. Rather than building verbose Java code yourself, you can model each function independently,
include it in the overall SDM, then generate the corresponding code. With the visual syntax, the advantage of using SDMs is obvious. You'll be able to use
familiar, easy-to-understand UML activity diagrams to establish your methods. Texually, SDMs extend the objected oriented paradigm by separating all classes,
references, and activities into different files, folders, and patterns.

If you're just joining us, read the next section for a brief overview of our running example so far, and how to download some files that will help you get
started right away. Alternatively, if you've completed Part II, click the link below to continue with your constructed learning box metamodel.

\begin{center}\texttt{$\triangleright$ \hyperlink{explanation}{Continue from Part II\ldots}}\end{center}
