
\section{A language definition problem?}

As in any area of study, metamodelling has its fair share of buzz words used by experts to communicate concisely.  Although some concepts might seem quite
abstract for a beginner, a well defined vocabulary is important so we know exactly what we are talking about.

The first step is understanding that metamodelling equates to language definition. This means that the task of building a system like our learning box can be  
viewed as defining a suitable language that can be used to describe the system.
This language oriented approach has a lot of advantages including a natural support for product lines (individual products are valid members of the language)
and a clear separation between platform independent and platform specific details.

So what constitutes a language?  The first question is obviously what the building blocks of your language ``look'' like. Will your language be textual? Visual?
 This representation referred to as the \emph{Concrete Syntax}\define{Concrete~Syntax} of a language and is basically an interface to end users who use the
language. In the case of our learning box, figure~\ref{fig:membox_illustration} can be viewed as a possible concrete syntax. As we are building a learning box
as a software system however, our actual concrete syntax  will probably be composed of GUI elements like buttons, drop-down menus and text fields.

Irrespective of what a language looks like, members of the language must adhere to the same set of ``rules''. For a natural language like
English,\define{Grammar} this set of rules is usually called a \emph{grammar}. In metamodelling, however, everything is represented as a graph of some kind and,
although the concept\define{Graph~Grammar} of a  \emph{graph grammar} is also quite well-spread and understood, metamodellers  more often use a \emph{type
graph}\define{Type~Graph} that defines what types and relations  constitute a language.

A graph that is a member of your language must \emph{conform to} the corresponding type graph for the language. To be more precise, it must be possible to type
the graph according to the type graph - the types and relations used in the graph must exist in the type graph and not contradict the structure defined there.
This way of defining membership to a language has many parallels to the class-object relationship in the object-oriented paradigm and
should seem very familiar for any programmer used to OO.\define{Abstract~Syntax} This type graph is referred to as the \emph{Abstract Syntax} of a language.

Often, one might want to further constrain a language, beyond simple typing rules. This can be accomplished with a further set of rules or constraints that
members of the language must fulfil in addition to being conform to the type graph.\define{Static~Sema\-ntics} These further constraints are referred to as the
\emph{Static Semantics} of a language.

With these few basic concepts, we can now introduce a further and central concept in metamodelling, the \emph{metamodel}\define{Metamodel}, which is basically a
simple class diagram. A metamodel defines not only the abstract syntax of a language but also some basic constraints (a part of the static semantics).

In analogy\define{Unification} to the ``everything is an object'' principle in the Object Oriented (OO) paradigm, in metamodelling, everything is a model! This
principle\define{Meta-meta\-model} is called \emph{Unification},  and carries many advantages. If everything is a model, a metamodel that defines (at least a part
of)\define{Modelling~Lan\-guage} a language must be a model itself. This means that it conforms to some \emph{meta-metamodel} which in turn defines a 
\emph{(meta)modelling language} or \emph{meta-language}.\define{Meta-Lang\-uage} For metamodelling with eMoflon, we support \emph{Ecore} as a modelling language
and it defines types like \texttt{EClass} and \texttt{EReference}, which we will be using to specify  our metamodels. Alternate modelling languages include MOF,
UML and Kermeta.

Thinking back to our learning box, we can define the types and relations we want to allow. We want an entire box of flashcards where each card is contained
within a partition, and each partition is contained within the box. Multiplicities are an example of static constraints that do not belong to the abstract
syntax, but can nonetheless be expressed in a metamodel.
An example could be that a card can only ever exist in one partition, or that a partition can have either one \texttt{next} partition, or none at all.

More complex constraints that cannot be expressed in a metamodel are usually specified using an extra \emph{constraint language}\define{Constraint~Language}
such as the Object Constraint Language (OCL). This idea, however,  is beyond the scope of this handbook. We'll stick to metamodels without needeing an extra
contstraint language.

$\textbf{A short recap:}$ We have learned that metamodelling starts with defining a suitable language. For the moment, we know that a language comprises a
concrete syntax (how the language ``looks''),  an abstract syntax (types and relations of the underlying graph structure), and static semantics (further
constraints that members of the language must fulfil). Metamodels are used to define the abstract syntax, and a part of the static semantics of a language,
while \emph{models} are graphs that conform to some\define{Model} metamodel (which can be typed according to the abstract syntax and must adhere to the static
semantics).

This handbook is meant to be hands-on, so enough theory! Lets define, step-by-step, a metamodel for a learning box using our tool, eMoflon.

\fancyfoot[RO]{ $\triangleright$ \hyperlink{static:starting vis}{Next [visual]\hspace{0.2cm}} \\ $\triangleright$ \hyperlink{static:starting tex}{Next [textual]}}