\newpage
\hypertarget{rules common}{}
\subsection{RulesClose \& IndexToLevelImplementation}
\texHeader

If you have done everything right up to this point, your project should save and build without error in Eclipse, and there should now be three generated
repository projects in the same working set. We're most concerned with \texttt{LearningBox\-To\-Dictionary\-Integration}, implements our TGG and its
rules. Confirm your folder resembles Fig.~\ref{fig:tggGenerated}


\begin{figure}[htbp]
\begin{center}
  \includegraphics[width=0.7\textwidth]{eclipse_generatedTGG}
  \caption{generated stuff}
  \label{fig:tggGenerated}
\end{center}
\end{figure}

Unfortunately, our TGG isn't yet complete. While we specified the \texttt{IndexTolevel} attribute constraint, we haven't given it any implementation code yet.
Let's quickly review these constraints before doing so.

Just like the patterns describing \emph{structural} correspondence,  \emph{attribute constraints} can be automatically \emph{operationalized} as required for
the forward concrete transformations. Even more interesting, a set of constraints might have to be ordered in a specific way depending on
the direction of the transformation, or they might have to be checked for pre-existing attributes. Others still might have to set values appropriately in
order to fulfill the constraint.

For built-in \emph{library} constraints such as \emph{eq}, \emph{addPrefix} and \emph{concat}, you do not need to worry about these details and can just focus
on expressing what should happen -- everything else is handled automatically.

In many cases however, a constraint might be extremely narrow and problem-specific, such as our \emph{indexToLevel} constraint. There might not be any
fitting combination of library constraints to express the consistency condition and so, a new attribute constraint must be declared before its use.

There is a list of \emph{adornments} in the declaration which specify the cases for which the constraint can be operationalized. Each adornment consists of a
\texttt{B} (bound) or \texttt{F} (free) variable setting for each argument of the constraint. It sounds complex, but its really quite simple, especially in
the context of our example:

\begin{description}

\item[BB] indicates that the \texttt{partition.index} and \texttt{entry.level} are both \emph{bound}, i.e., they already have assigned values.
In this case, the \emph{operation} must check if the assigned values are valid and correct.

\item[BF] indicates that \texttt{partition.index} is \emph{bound} and \texttt{entry.level} is \emph{free}, i.e., the operation must determine and assign the
correct value to \texttt{entry.level} using \texttt{partition.index}.

\item[FB] indicates that \texttt{partition.index} is \emph{free} and \texttt{entry.level} is \emph{bound}, i.e., the operation must determine and assign the
correct value to \texttt{parti\-tion.in\-dex} using \texttt{entry.level}.

\end{description}

Note that we decide not to support \textbf{FF} as we would have to generate a consistent pair of \texttt{index} and \texttt{level}. Although this is possible
and might even make sense for some applications, it does not in the context of partitions and entries (the pairs are not unique, so which pair should we
take? \texttt{partition2} and set it to \texttt{beginner}?).

At compile time, the set of constraints (also called \emph{Constraint Satisfaction Problem} (CSP)) for every TGG rule is ``solved'' for each case (forward,
backward) by operationalizing all constraints and determining a feasible sequence in which the operations can be executed, compatible to the declared adornments
of each constration. If the constraints cannot be solved, an exception is thrown.

Now that we an understanding behind the construction of a new attribute constraint, let's implement \texttt{IndexToLevel}.

\begin{itemize}
\item[$\blacktriangleright$] Locate and open \texttt{IndexToLevel.java} under ``src/csp.constraints'' in \texttt{LearningBoxToDictionaryIntegration}.

\item[$\blacktriangleright$] As you can see, code has been generated in order to handle the current unimplemented state of \texttt{IndexToLevel}. Copy
and paste the the code in Fig.~\ref{fig:indexToLevel} on the next page into the file to replace it.\footnote{You can format the code by pressing
\texttt{Ctrl + shift + F}}

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}[language=Java,backgroundcolor=\color{white}, keywordstyle={\bfseries\color{purple}}]
package csp.constraints;

import java.util.Arrays;
import java.util.List;
import TGGLanguage.csp.Variable;
import TGGLanguage.csp.impl.ConstraintImpl;

public class IndexToLevel extends ConstraintImpl {

	private List<String> levels = Arrays.asList(new String[] { "master",
			"advanced", "beginner" });

	public void solve(Variable<Number> var_0, Variable<String> var_1) {

		int index = var_0.getValue().intValue();
		String level = var_1.getValue();

		String bindingStates = getBindingStates(var_0, var_1);

		switch (bindingStates) {
		case "BB":
			setSatisfied(levels.get(index).equals(level));
			break;

		case "BF":
			if (index < 0)
				var_1.setValue(levels.get(0));
			else if (index > 2)
				var_1.setValue(levels.get(2));
			else
				var_1.setValue(levels.get(index));

			var_1.setBound(true);
			setSatisfied(true);
			break;

		case "FB":
			index = levels.indexOf(level);
			if (index == -1) {
				setSatisfied(false);
			} else {
				var_0.setValue(index);
				var_0.setBound(true);
				setSatisfied(true);
			}
			break;
		}
	}
}
\end{lstlisting}
  \caption{Implementation of our custom attribute constraint}
  \label{fig:indexToLevel}
\end{center}
\end{figure}

\vspace{0.5cm}

To briefly explain, the \texttt{levels} list sets each String \texttt{level} to 0,1, or 2, which correspond to the \texttt{index} values of each partition.
You'll notice that instead of setting `master' to 2, we have set it to 0. This is because unlike an \texttt{entry} in \texttt{dictionary}, the postition of each
\texttt{card} in \texttt{box} is \emph{not} based on difficulty, but simply how it has been moved as a result of the user's guess. Easy cards are therefore more
likely to be in the final partiton by moving through the box quickly, while challenging cards are most likely to be near the start, as they keep getting
sent backwards.

\vspace{0.5cm}

As you can also see, there is a switch statement structure, based on whatever adornment is currently active. For all cases, \texttt{setSatisfied} informs the
TGG whether or not the constraint (and by consequence, the rule) can be executed. For \texttt{BF}, it suggests that if a negative partition were to exist, to
simply set its index value to 0. Similarily, if there was ever a partition more than 2 (i.e., \texttt{partition4}), to set its index to the highest difficulty
level, 2. Otherwise, \texttt{BF} simply gets the index of the partition, assigns it so it becomes bound, and finishes. In the final case, where \texttt{level}
is already known (i.e., transforming an \texttt{entry} into a \texttt{card}), if the String \texttt{level} cannot be matched to any of those in the list, state
that it does not exist, and the rule cannot be completed. Otherwise, bind the value and complete the constraint.

\vspace{0.5cm}

\item[$\blacktriangleright$] Save the file and right-click on the \texttt{Learning\-Box\-To\-Dictionary\-Integration} root folder, and navigate to
``eMoflon / Clean (and Build)'' to build the project. If no errors were raised, congratulations! Your TGG Schema and Rule pair are now complete.

\end{itemize}
