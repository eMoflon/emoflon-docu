\section{Triple Graph Grammars in a nutshell}
\label{sec:nutshell}
\genHeader

Triple graph grammars~\cite{tgg:schuerr_94,sk2008,Klar2010} are a declarative, rule-based technique of specifying the simultaneous evolution of three connected
graphs.  Basically, they're just a bunch of rules. Each rule is quite similar to one \emph{story pattern}, given that they describe how a graph structure is to
be built-up with a precondition (LHS) and postcondition (RHS).

Wait a tick. What's the difference between TGGs and SDMs then?

A TGG rule will always describe how a \emph{graph triple}\define{Graph Triple}evolves, and triples can be interpreted as consisting of a source,
correspondence, and target component. SDMs however, only deal with a single target and source pair. This means that executing a sequence of TGG rules results in
a source graph and a target graph, which are \emph{only} connected via nodes in a correspondence graph. 

Please note that the names ``source'' and ``target'' are arbitrarily chosen and do not imply a certain transformation direction. Naming the graphs ``left'' and ``right'', or ``foo'' and ``bar'' would also be fine. The
important thing to remember is that TGGs are \emph{symmetric} in nature.

So far so good, but now you should be asking yourself the following question: ``What on earth does all this have to do with bidirectional model transformation?''

\newpage

We believe there are two main keys to understanding TGGs:

\begin{description}

\item[(1) A TGG defines a consistency relation:]% 
Given a TGG (a set of rul\-es), you can take a look at a source graph $S$ with a target graph $T$ and say if
they are \emph{consistent} with respect to the TGG. How?  Simply check if a triple ($S\leftarrow C\rightarrow T$) can be created using the rules of the TGG,
where $S$ is the source component, $T$ is its target component, and $C$ is the correspondence component~\cite{Hermann2011a}. $C$ would be known as the
correspondence graph. If such a triple can be created, then the given graphs are consistent, denoted by $S \Leftrightarrow_{TGG} T$. This consistency relation
can immediately be used to check if a current bidirectional transformation (i.e., a pair unidirectional forward ($f$) and backward ($b$) transformations) is
consistent. \emph{A TGG can therefore be viewed as a specification of how the transformations \emph{should} behave ($S \Leftrightarrow_{TGG} f(S)$ and $b(T)
\Leftrightarrow_{TGG} T$)}.
	
\item[(2) The consistency relation can be operationalized:]% 
Now comes the surprising (and extremely cool) part - forward \emph{and} backward rules can be derived automatically from every TGG
rule~\cite{Giese2010,Hermann2011a}! To help you understand, the description of the simultaneous evolution of the source, correspondence, and target graph is
\emph{sufficient} to derive a forward transformation. For example, if you're given a source, consistent correspondence, target graph, and backward
transformation, you can find the forward transform. Since these derived rules must be executed in order to perform forward and backward transformations, they
are called \emph{operational} rules as opposed to the TGG \emph{declarative} rules. The derivation process is therefore also referred to as
the\define{Operationalization}\emph{operationalization} of a TGG.
	
\end{description}

Before we summarizing and getting our hands dirty on a concrete example, here are a few extra points for the interested reader:  

\begin{itemize}

\item Many more rules can be automatically derived from the consistency relation including inverse rules to \emph{undo} a step in a forward/backward
transformation~\cite{LAVS_ICGT_2012}, and rules that simply check consistency of an existing triple of source, correspondence and target graphs. \update

\item You might be wondering why we even need the correspondence graph. Can't we just compare the target and source graphs? 

Firstly, the correspondence graph can be viewed as explicit traceability links, which are always nice to have. With these you can, i.e., immediately \emph{see}
which element relates to which after a forward/backward transformation. There's no guessing, no heuristics, and no interpretation or ambivalence. The
information is just there! This clearly fulfils our traceability goals.

The second reason is a bit more subtle, and difficult to explain without a concrete TGG, but we'll do our best. The main point is that the forward\footnote{Note
that the TGGs are symmetric and forward/backward can be interchanged freely.  As it is cumbersome to always write forward/backward, we shall simply say
forward} transformation is \emph{not} injective and cannot be inverted! How is it possible to we provide a backward transformation then?

Remember, a function can only be inverted if it is \emph{bijective},\define{Bijective}meaning it is both \emph{injective}\define{Injective}and
\emph{surjective}.\define{Surjective}To accomodate this, when executing the forward transformation, eMoflon sort of ``cheats'' and, if a choice was made, 
remembers what target element was chosen.\footnote{It's `cheating' since this choice is what makes the transformation non-injective.} In this way, eMoflon
\emph{bidirectionalize}s the transformation on-the-fly with correspondence links.

If somehow lose the correspondence graph, no worries, because the \emph{same} TGG specification that has been used to derive your forward and backward
transformations can also be used to reconstruct the correspondence model between two existing source and target models (to a certain degree).\footnote{We refer
to this type of operational rule as \emph{link creation}}

\end{itemize}
This was a lot of information to absorb all at once, so it may make sense to re-read this section after working through the example. In any case, enough theory!
Grab your computer (if you're not hugging it already) and get ready to churn out some TGGs!
