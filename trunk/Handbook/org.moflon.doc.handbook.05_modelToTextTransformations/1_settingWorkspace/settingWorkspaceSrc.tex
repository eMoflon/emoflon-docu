\newpage
\section{Setting up your workspace}
\genHeader

Nowadays, \emph{no one} writes a complex parser completely by hand. Although this is sometimes still necessary for syntactically challenging languages, most
parsers can be quickly whipped up using context-free \emph{string grammars}\footnote{For simple cases, \emph{regular expressions} can also be used} that are
typically written in Extended Backus-Naur Form (EBNF)\define{EBNF}. ANTLR is a tool that can generate a parser from this compact specification for
a host of target programming languages, including Java. Although ANTLR might not be the most efficient or powerful parser generator, it's open-source, well
documented and supported, and allows for a pragmatic and elegant fallback to Java if things get nasty and we have to resort to some dirty tricks to get the job
done.

To set up your workspace for the model-to-text transformation, you have two options: (1) Import a cheat package with everything already
prepared (useful if you're just joining us), or (2) if you've worked through the previous part, continue with your existing workspace. 
Both options should work, but we have only tested and updated all screenshots for Option (1) and thus highly recommend this.

As some of you are just reading this handbook without actually getting your hands dirty with an implementation (beware: no pain, no gain!), we have included a
screenshot of the dictionary metamodel that you get with both options in our visual (Fig.~\ref{ea:dictLang}) and textual (Fig.~\ref{eclipse:dictLangMetamodel})
concrete syntax.

\vspace{0.5cm}

% --- Dictionary metamodels --
\begin{figure}[htbp]
\begin{centering}
  \includegraphics[width=\textwidth]{ea_dictionaryMetamodel}
  \caption{Metamodel for dictionaries (visual concrete syntax)}
  \label{ea:dictLang}
  \end{centering}
\end{figure}

\newpage

\begin{figure}[h!]
  \hspace{-1.5cm}
  \includegraphics[width=1.2\textwidth]{eclipse_dictionaryMetamodel}
  \caption{Metamodel for dictionaries (textual concrete syntax)}
  \label{eclipse:dictLangMetamodel}
\end{figure}

\vspace{0.5cm}

% --- Option descriptions --
\begin{description}

\item[Option 1: Import a complete cheat package]

\item[$\blacktriangleright$] \hspace{0.3cm} Import the Part V `cheat package' by selecting ``New" in the toolbar, and the cheat package in the concrete syntax
of your choice (Fig.~\ref{eclipse_cheatPackage}).

\begin{figure}[htbp]
\begin{center}
  \includegraphics[width=0.65\textwidth]{eclipse_loadDictionaryProject}
  \caption{Load the cheat package for Part V into your workspace}
  \label{eclipse_cheatPackage}
\end{center}
\end{figure}

\vspace{0.5cm}

% -- Export/Import ---
\item[Option 2: Continue with the workspace from Part IV]


\item[$\blacktriangleright$] \hspace{0.3cm} Use the same metamodel for \texttt{Dictionary} as completed in Part IV. Just make sure you haven't radically changed
the dictionary metamodel (i.e., it still closely resembles the metamodel in either Fig.~\ref{ea:dictLang} or Fig.~\ref{eclipse:dictLangMetamodel}). Everything
else should work fine using the exact same workspace but remember, your screen may look different than our screenshots.

\end{description}


We recommend reviewing the dictionary metamodel until you feel comfortable with what you'll be working with. 

\newpage

\texttt{DictionaryLanguage} is only one of two metamodels that we'll be using to specify the TGG transformation. After all, TGGs typically require separate
source and target metamodels. The second metamodel involved in the transformation will be eMoflon's standard \texttt{MocaTree} language.\footnote{MOCA stands
for Moflon Code Adapter (not coffee, sorry.)} It basically combines concepts from a filesystem (folders and files), XML (text-only nodes and attributes), and a
general indexed containment hierarchy. It is provided by our Eclipse plugin and is automatically added to the build path, so it won't actually appear
anywhere in your Eclipse workspace.

Figure~\ref{mocaTreeMetamodel} is a visual depiction of this MocaTree model.\footnote{If you are using the visual syntax, feel free to view a detailed metamodel
by opening \texttt{dictionary.eap}, navigating to the \texttt{MocaTree} EPackage, and opening its diagram.} As you can see, the most important element is
\texttt{Node}. Note that a single \texttt{Node} can store any number of \texttt{Attribute} or \texttt{Text} elements (subnodes), but only belongs to one
\texttt{File}. If you look closer at \texttt{File}, you'll also notice that it belongs to a single \texttt{Folder}. \texttt{Folder} is able to store any number
of \texttt{File}s or subfolders.

\newpage

You can see that all elements inherit an \texttt{index} and \texttt{name} attribute. \texttt{Index} can be used to demand a certain \emph{order}
of nodes in a tree, otherwise not guaranteed by default (i.e., to enforce a hierarchy), while \texttt{name} can be any arbitrary string value. 

\vspace{1cm}

\begin{figure}[htbp]
  \begin{centering}
  \includegraphics[width=\textwidth]{MocaTreeMetamodel}
  \caption{Visual depiction of the MocaTree metamodel}
  \label{mocaTreeMetamodel}
  \end{centering}
\end{figure}

\vspace{1cm}

Enough chatting -- let's begin by creating the TGG project that will implement our model-to-text transformation.

\jumpDual{initialize vis}{initialize tex}

\newpage

\input{../1_settingWorkspace/vis_setWkspSrc}

\input{../1_settingWorkspace/tex_setWkspSrc}

\input{../1_settingWorkspace/addParserSrc}
