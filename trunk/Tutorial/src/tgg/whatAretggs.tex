\section{Triple Graph Grammars in a Nutshell}

Triple graph grammars are a declarative, rule-based technique of specifying the simultaneous evolution of three consistently connected graphs.
If you have read the previous sentence at least three times and are still scratching your head wondering if you need a cup of coffee -- well then welcome to the club\footnote{If not then congrats, stop reading, and go grab some real (academic) papers on TGGs.} ;)

A TGG is basically just a bunch of rules.
Each rule is actually quite similar to a \emph{Story Pattern} (see Page~\pageref{story-pattern}) and describes with a precondition (LHS) and postcondition (RHS) how a graph structure is to be built-up.
So what's the difference to SDMs?  
Well, a TGG rule always describes how a \emph{graph triple} evolves and triples can be interpreted as consisting of a source component, a correspondence component and a target component.
This means that executing a sequence of TGG rules results in a source graph and a target graph, which are \emph{only} connected via nodes in a correspondence graph.
Note that the names ``source'' and ``target'' are arbitrarily chosen and do not imply a certain transformation direction.
Naming the graphs ``left'' and ``right'', ``foo'' and ``bar'', \ldots would also be fine, but some smart guys decided years ago to name it source and target and, hence, we're still following this convention. 

So far so good, but right now you should be asking yourself the following question: What the {\huge heck} does this have to do with bidirectional model transformation?!  \emph{That}, Detective, is the right question. Program terminated\footnote{Memorable quote from \emph{I, Robot}.}.
\clearpage

We believe there are two main keys to understanding TGGs:
\begin{description}
\item[(1) A TGG defines a consistency relation:]
	Given a TGG (remember -- just a bunch of rules), you can take a look at a source graph $S$ and a target graph $T$ and say if they are \emph{consistent} with respect to the TGG.
	How?  You simply check if a triple $S\leftarrow C\rightarrow T$ can be created using the rules of the TGG, which has the source graph $S$ as its source component and the target graph $T$ as its target component, and some correspondence graph $C$ as its correspondence component.
	If such a triple can be created then the given source and target graphs are consistent.
	Let's denote this as $S \Leftrightarrow_{TGG} T$.
	This consistency relation can already be used to check if a bidirectional transformation, i.e., a pair of forward ($f$) and backward ($b$) transformations are consistent (according to the TGG which can be viewed as a specification of how the transformations are to behave):  $S \Leftrightarrow_{TGG} f(S)$ and $b(T) \Leftrightarrow_{TGG} T$.
	
\item[(2) The consistency relation can be operationalized:]
Now comes the surprising (and extremely cool) part -- a forward \emph{and} backward rule can be derived automatically from every TGG rule!
Just to make sure you got the point:  The description of the simultaneous evolution of the source, correspondence and target graphs is \emph{sufficient} to derive a forward transformation, i.e., given source, determine consistent correspondence and target graphs, and a backward transformation, i.e., given target, determine consistent correspondence and source graphs.
If you can't imagine why then just accept it as magic for now.
As these derived rules are actually executed to perform forward and backward transformation, they are called \emph{operational} rules as opposed to the TGG rules, which are called \emph{declarative} rules.
The derivation process, therefore, is referred to as the \emph{operationalization} of a TGG. 
\end{description}

Before we sum up and get our hands dirty on our concrete example, just a few extra points for the interested reader:  
\begin{itemize}
\item A lot more can be automatically derived from the consistency relation including inverse rules to \emph{undo} a step in a forward/backward transformation and rules that simply check consistency of an existing triple of source, correspondence and target graphs.

\item Why do we need the correspondence graph?  Hmm\dots~  Thats a hard one ;)  Well, first of all it can be viewed as explicit traceability links which are quite nice to have, i.e., you \emph{see} which element relates to which after a forward/backward transformation. No guessing, no heuristics, no interpretation or ambivalence -- the information \emph{is} just there!
Isn't that nice to have?
The second reason is a bit more subtle and difficult to explain without a concrete TGG:  The point is mainly that the forward\footnote{Note that the TGGs are symmetric and forward/backward can be interchanged freely.  As it is becoming a pain to always write forward/backward we shall just say forward as from now on.} transformation is \emph{not} injective and cannot be inverted!
So how can we provide a backward transformation??
If you paid attention in school, alarm bells should be going off in your head now -- ding ding ding, a function can only be inverted if it is bijective which means injective and surjective\footnote{If you don't have an idea what injective/surjective/bijective means then ask Google.}, ding ding\ldots~
Good point!  When executing the forward transformation we sort of ``cheat'' and remember what target element was chosen if there was a choice (exactly this choice makes the transformation non-injective right?).
In this way we \emph{bidirectionalize} the transformation on-the-fly by creating correspondence links.
Got it? great! No?  Then just remember: the correspondence model is cute and for some reasons also important.
But if you loose it somehow - don't be afraid, because the same TGG specification that has been used to get your forward and backward transformations, can also be used to reconstruct the correspondence model between two existing source and targte models (at least up to a certain degree).
\end{itemize}

That was quite a lot at once so it might make sense to re-read these sections \emph{after} working on the example.
Enough theory!  Grab your computer (if you're not hugging it already) and lets churn out some TGGs!
