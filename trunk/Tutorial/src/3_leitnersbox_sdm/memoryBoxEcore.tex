\chapter{Leitner's Learning Box}
\label{chap:membox}

The toughest part of learning a new language  is often building up a sufficient vocabulary.
This is usually accomplished by repeating a long list of words again and again till they stick.
A \emph{Leitner's learning box}\footnote{http://en.wikipedia.org/wiki/Leitner\_system} is a simple but ingenious little contraption to support this tedious process of memorization.

As depicted in Fig.~\ref{fig:membox_illustration}, it consists of a series of compartments or partitions usually of increasing size.
The content to be memorized is written on a series of cards  which are initially placed in the first partition.
All cards in the first  partition should be repeated everyday and cards that have been successfully memorized are placed in the next partition.
Cards in all other partitions are only repeated when the corresponding partition is full and cards that are  answered correctly are moved one partition forward in the box.
Challenging  cards that have been forgotten are treated as brand new cards and are always  placed right back into the first partition regardless of how far in the box they  had progressed.

These ``rules'' are depicted by the green and red arrows in  Fig.~\ref{fig:membox_illustration}.
The basic idea is to repeat difficult cards as often as necessary and not to waste time on easy cards which
are only repeated now and then to keep them in memory.
The increasing size of the partitions represents how words are easily placed in our limited short term memory and slowly move in our theoretically unlimited long term memory if practised often enough.
%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=0.5\textwidth]{pics/installationAndSetup/membox_illustration}
  \caption[]{Possible \emph{Concrete Syntax} of a Leitner's Learning Box.}
  \label{fig:membox_illustration}
\end{center}
\end{figure}
\FloatBarrier

A learning box is an interesting system, because it consists clearly of a static structure (the box, partitions and their sizes, cards with their sides and corresponding content) and a set of rules that describe the dynamic aspects
(behaviour) of the system.
In the rest of the tutorial we shall build a complete learning box from scratch in a model-driven fashion and use it to introduce fundamental concepts in metamodelling and \emph{Model-Driven Software Development} (MDSD) in general.

\section{A language definition problem?}

As in any area of study, metamodelling has its fair share of buzz words used by experts to communicate concisely.  Although some concepts might seem quite abstract for a beginner, a well defined vocabulary is important so we know
exactly what we are talking about.

The first step is understanding that metamodelling equates to language definition.
This means that the task of building a system like our learning box can be viewed as defining a suitable language that can be used to describe the system.
This language oriented approach has a lot of advantages including a natural support for product lines (individual products are valid members of the language) and a clear separation between platform independent and platform specific details.

So what constitutes a language?  The first question is obviously  how the building blocks of your language actually ``look'' like.
Is your language to be textual?  Visual?  This is referred to as the \emph{Concrete Syntax} of a language and is basically an interface to end users who use the language.
\marginpar{\emph{Concrete Syntax}}
In the case of our learning box, Fig.~\ref{fig:membox_illustration} can be viewed as a possible concrete syntax.
As we are however building a learning box as a software system, our actual concrete syntax  will probably be composed of GUI elements like buttons, drop-down menus and text fields.

Irrespective of how a language looks like, members of the language must adhere to the same set of ``rules''.
\marginpar{\emph{Grammar}}
For a natural language like English, this set of rules is usually called a \emph{grammar}.
In metamodelling, however, everything is represented as a graph of some kind and, although the concept of a  \emph{graph grammar} is also quite well-spread and understood, metamodellers  more often use a \emph{type graph} that defines what types and relations  constitute a language.
\marginpar{\emph{Graph Grammar}}
\marginpar{\emph{Type Graph}}
A graph that is a member of your language must \emph{conform to} the corresponding type graph for the language.
To be more precise, it must be possible to type the graph according to the type graph, i.e., the types and relations used in the graph must exist in the type graph and not contradict the structure defined there.
\marginpar{\emph{Abstract Syntax}}
This way of defining membership to a language has many parallels to the class-object relationship in the object-oriented paradigm and should seem very familiar for any programmer used to OO.
This type graph is referred to as the \emph{Abstract Syntax} of a language.

Very often, one might want to further constrain a language, beyond simple typing rules.
\marginpar{\emph{Static Semantics}}
This can be accomplished with a further set of rules or constraints that members of the language must fulfil in addition to being conform to the type graph.
These further constraints are referred to as the \emph{Static Semantics} of a language.

With these few basic concepts, we can now introduce a further and central concept in metamodelling, the \emph{metamodel} (basically a simple class diagram).
\marginpar{\emph{Metamodel}}
A metamodel defines not only the abstract syntax of a language but also some basic constraints (a part of the static semantics).
Thinking back to our learning box, we could define the types and relations we want to allow, e.g.,  a box with partitions, cards, the box contains partitions that contain cards.
Multiplicities are an example for constraints that are no longer part of the abstract syntax and belong to static semantics, but can nonetheless be expressed in a metamodel.
For example, that a card can only be in one partition, or that a partition has only one next partition or none.
\marginpar{\emph{Constraint Language}}
More complex constraints that cannot be expressed in a metamodel are usually specified using an extra \emph{constraint language} such as OCL (the Object Constraint Language).
This goes beyond this tutorial however and we'll stick to metamodels without using an extra constraint language.

$\textbf{A short recap:}$  we have learnt that metamodelling starts with defining a suitable language.
For the moment, we know that a language comprises a concrete syntax (how does the language look like),  an abstract syntax (types and relations of the underlying graph structure), and static semantics (further constraints that members of the language must fulfil).
Metamodels are used to define the abstract syntax and a part of the static semantics of a language, while \emph{models} are graphs that conform to some
\marginpar{\emph{Model}}
metamodel (can be typed  according to the abstract syntax and adhere to the static semantics).

This tutorial is meant to be be hands-on so enough theory!
Lets define, step-by-step, a metamodel for our learning box using our tool eMoflon.

\section{Abstract syntax and static semantics}
\label{sec:abstractSyntax}

\begin{enumerate}
\item[$\blacktriangleright$] Switch to EA, choose \texttt{Demo} and click on the button \texttt{Add a Package} as depicted in Fig.~\ref{fig:new_package}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.7\textwidth]{pics/memBoxBilder/memBox01.png}
	\caption{Add a new package to \texttt{Demo}.}
	\label{fig:new_package}
\end{figure}

\item[$\blacktriangleright$] In the dialogue that pops up (Fig.~\ref{fig:new_package_name}), choose \texttt{Class View}, enter \texttt{Learning\-Box\-Language} as the name of the new package and click \texttt{OK}.

\begin{figure}[htbp]
	\centering
    \includegraphics[width=0.33\textwidth]{pics/memBoxBilder/memBox02.png}
	\caption{Enter the name of the new package.}
	\label{fig:new_package_name}
\end{figure}
\end{enumerate}
\FloatBarrier

In your EA workspace the \texttt{Project Browser} should now look like Fig.~\ref{fig:new_package_completed}.
\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.53\textwidth]{pics/memBoxBilder/memBox03.png}
	\caption{State after creating the new package.}
	\label{fig:new_package_completed}
\end{figure}
\FloatBarrier

\begin{enumerate}
\item[$\blacktriangleright$] Now click the button \texttt{New Diagram} (Fig.~\ref{fig:diagram}).

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.72\textwidth]{pics/memBoxBilder/memBox04.png}
	\caption{Add a diagram.}
	\label{fig:diagram}
\end{figure}
\FloatBarrier
\clearpage

\item[$\blacktriangleright$] In the dialog that pops up (Fig.~\ref{fig:diagram_type}), choose \texttt{Ecore Diagram} and  \texttt{OK}.
\end{enumerate}

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.7\textwidth]{pics/memBoxBilder/memBox05.png}
	\caption{Choose type of diagram.}
	\label{fig:diagram_type}
\end{figure}
\FloatBarrier

In analogy to the ``everything is an object'' principle in the OO paradigm, in metamodelling, everything is a model.
\marginpar{\emph{Unification}}
This principle is called \emph{Unification} and has a lot of advantages.
If everything is a model, a metamodel that defines (at least a part of) a language must be a model itself.
\marginpar{\emph{Meta-metamodel}}
\marginpar{\emph{Meta-Language}}
\marginpar{\emph{Modelling Language}}
This means that it conforms to some \emph{meta-metamodel} which defines a \emph{(meta)modelling language} or \emph{meta-language}.
For metamodelling with eMoflon, we support \emph{Ecore} as a modelling language and it defines types like \texttt{EClass} and \texttt{EReference}, which we will be using to specify  our metamodels.
Other modelling languages include MOF, UML and Kermeta.

After creating the new diagram, your  \texttt{Project Browser} should now resemble Fig.~\ref{fig:diagram_completed}.

\begin{enumerate}
\item[$\blacktriangleright$] Double-click the newly created diagram to ensure that it is open.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.5\textwidth]{pics/memBoxBilder/memBox06.png}
	\caption{State after creating diagram.}
	\label{fig:diagram_completed}
\end{figure}

\item[$\blacktriangleright$] To the left of the workbench in EA, a \emph{Toolbox} should have appeared\footnote{If not, choose ``View/Diagram Toolbox'' to show the current toolbox.} containing the types available in Ecore for metamodelling (Fig.~\ref{fig:eclass}).
Click on \texttt{EClass} and click in the open diagram (the main window in EA).

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.7\textwidth]{pics/memBoxBilder/memBox07.png}
	\caption{Create an EClass.}
	\label{fig:eclass}
\end{figure}


\item[$\blacktriangleright$] In the dialogue that pops-up, enter \texttt{Box} as the name of the class and click \texttt{OK} (Fig.~\ref{fig:eclass_properties}).
This dialogue can always be invoked by double-clicking the class and contains many other properties we'll be looking into later in the tutorial.
In general, a similar ``properties'' dialogue can be opened in the same fashion for almost every element in EA.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.6\textwidth]{pics/memBoxBilder/memBox08.png}
	\caption{Enter properties of EClass.}
	\label{fig:eclass_properties}
\end{figure}

\item[$\blacktriangleright$] After creating \texttt{Box}, your EA workspace should resemble Fig.~\ref{fig:eclass_completed}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.9\textwidth]{pics/memBoxBilder/memBox09.png}
	\caption{State after creating \texttt{Box}.}
	\label{fig:eclass_completed}
\end{figure}


\item[$\blacktriangleright$] Now create \texttt{Partition} and \texttt{Card} in the same way, until your workspace resembles Fig.~\ref{fig:all_eclasses}.
These are the main classes for our learning box.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.9\textwidth]{pics/memBoxBilder/memBox10.png}
	\caption{Main classes in our metamodel.}
	\label{fig:all_eclasses}
\end{figure}

\item[$\blacktriangleright$] Now choose \texttt{Box}, right-click to call up the context menu and choose \texttt{Att\-ri\-butes\ldots} (Fig.~\ref{fig:attribute}).

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.52\textwidth]{pics/memBoxBilder/memBox11.png}
	\caption{Context Menu for a class.}
	\label{fig:attribute}
\end{figure}
\FloatBarrier


\item[$\blacktriangleright$] In the dialogue that pops-up, enter \texttt{name} as the name of the attribute, choose \texttt{EString} as its type and press \texttt{Save} (Fig.~\ref{fig:attribute_properties}).
A new attribute for the same class can be added by choosing \texttt{New}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.7\textwidth]{pics/memBoxBilder/memBox13.png}
	\caption{Adding attributes to a class.}
	\label{fig:attribute_properties}
\end{figure}

\item[$\blacktriangleright$] Add attributes to the other classes until your workspace resembles
Fig.~\ref{fig:attribute_completed}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.2\textwidth]{pics/memBoxBilder/memBox14.pdf}
	\caption{Main classes with attributes.}
	\label{fig:attribute_completed}
\end{figure}
\FloatBarrier

\item[$\blacktriangleright$] A fundamental gesture in EA is \emph{Quick Link}.
Quick Link is used to create links between elements in a context sensitive manner.
To use Quick Link, choose an element and note the little black arrow in its top-right corner (Fig.~\ref{fig:quicklink}).

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.4\textwidth]{pics/memBoxBilder/memBox23.png}
	\caption{Quick Link is a central gesture in EA.}
	\label{fig:quicklink}
\end{figure}
\FloatBarrier

Now click on the black arrow and pull to another element you wish to ``quick link" to.
In this case quick link from \texttt{Box} to \texttt{Partition}.
In the context-menu that pops-up, choose \texttt{EReference} (Fig.~\ref{fig:ereference}).

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.5\textwidth]{pics/memBoxBilder/memBox24.png}
	\caption{Create a reference via Quick Link.}
	\label{fig:ereference}
\end{figure}
\FloatBarrier

\item[$\blacktriangleright$] Double click the reference to invoke a dialogue (Fig.~\ref{fig:ereference_properties}), with which the direction of the reference can be set.
The default is \texttt{Source} $\Rightarrow$ \texttt{Target} and must be changed to \texttt{Bi-Directional} for our \texttt{Box}$\Leftrightarrow$\texttt{Partition} connection.
A \texttt{Name} can also be entered, which is only used for documentation purposes and is not relevant for code generation.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.6\textwidth]{pics/memBoxBilder/memBox25.png}
	\caption{Enter properties of the reference.}
	\label{fig:ereference_properties}
\end{figure}

\item[$\blacktriangleright$] In the same dialogue choose \texttt{Source Role} and enter the values in Fig.~\ref{fig:reference_ends} to set the properties for the ``source'' end of the reference (the \texttt{Box} role).
Important is a name for the role (\texttt{box}), the \texttt{Multiplicity}, \texttt{Aggregation} and \texttt{Navigability}.  Repeat the process for the \texttt{Target Role}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.6\textwidth]{pics/memBoxBilder/memBox26.png}\\
  \vspace{0.2cm}
  \includegraphics[width=0.6\textwidth]{pics/memBoxBilder/memBox27.png}
	\caption{Enter properties for source and target of reference.}
	\label{fig:reference_ends}
\end{figure}
\FloatBarrier
\end{enumerate}

Navigable ends are mapped to class attributes with getters and setters in Java and therefore \emph{must} have a specified name and  multiplicity for successful code generation.
Corresponding values for non-navigable ends can  be regarded as additional documentation and do not have to be specified.

The multiplicity of a reference controls if the relation is mapped to a Java Collection (\texttt{*},  \texttt{1..*}, \texttt{0..*}), or a single valued class attribute (\texttt{1}, \texttt{0..1}).

In Ecore, the aggregation values of a reference can either be \texttt{none} or \texttt{com\-po\-site}.
Composite means that the current role is that of a \emph{container} for the opposite role.
In our case for example, \texttt{box} is a container for \texttt{partitions}.\\
This has a series of consequences: (1) every element must have a container, (2) an element cannot be in more than one container at the same time, and (3) a container's contents are deleted together with the container.
Non-composite (\texttt{none}) means that the current role is not that of a container and the rules for containment do not hold (reference is a simple ``pointer'').

If you've done everything right, your workspace should now resemble Fig.~\ref{fig:ereference_completed} with a relation between \texttt{Box} and \texttt{Partition}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.33\textwidth]{pics/memBoxBilder/memBox28.pdf}
	\caption{\texttt{Box} contains \texttt{Partition}s.}
	\label{fig:ereference_completed}
\end{figure}
\FloatBarrier

\begin{enumerate}
\item[$\blacktriangleright$] Create a bidirectional reference\footnote{To be precise, \emph{all} references in Ecore are actually unidirectional.
A ``bidirectional'' reference in our metamodel is in reality mapped to two \texttt{EReferences} that are opposites of each other.
We however believe it is simpler to handle these pairs as single references and prefer this concise concrete syntax.} between \texttt{Partition} and \texttt{Card} and two unidirectional self-references for \texttt{Partition} according to Fig.~\ref{fig:ereferences_all}\footnote{If you have difficulties deciphering the role names and other details in the screen shot please refer to Fig.~\ref{fig:metamodel_complete} for a better diagram of the metamodel.}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.5\textwidth]{pics/memBoxBilder/memBox34.pdf}
	\caption{All relations in our metamodel.}
	\label{fig:ereferences_all}
\end{figure}
\end{enumerate}
\FloatBarrier

Every system has, in addition to its static structure, certain dynamic aspects that describe the system's behaviour and how it evolves over time or reacts to external stimulus.
\marginpar{\emph{Dynamic Semantics}}
In a language, these rules that govern the dynamic behaviour of a system are referred to collectively as the \emph{Dynamic Semantics} of the language.
Although these rules can be defined as a set of separate \emph{Model Transformations}, we take a holistic approach and advocate integrating the transformations directly in the metamodel as operations.
This fits nicely to the object-oriented paradigm and is quite natural in many cases.

In the next few steps we shall define the \emph{signatures} of some operations for our learning box.
We will of course use SDMs to \emph{implement} the methods later.

\begin{enumerate}
\item[$\blacktriangleright$] Right-click \texttt{Partition} to invoke the context-menu depicted in Fig.~\ref{fig:add_operation} and choose \texttt{Operations\ldots}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.7\textwidth]{pics/memBoxBilder/memBox35.png}
	\caption{Add an operation.}
	\label{fig:add_operation}
\end{figure}
\FloatBarrier

\item[$\blacktriangleright$] In the dialogue that pops-up (Fig.~\ref{fig:operation_properties}), enter \texttt{empty} as the \texttt{Name} of the operation, leave the \texttt{Return Type} as \texttt{void}.  Press \texttt{Save}.

\begin{figure}[htbp]
	\centering
  	\includegraphics[width=0.7\textwidth]{pics/memBoxBilder/memBox37.png}
	\caption{Properties for operation.}
	\label{fig:operation_properties}
\end{figure}
\FloatBarrier

\item[$\blacktriangleright$] In the same dialogue, press \texttt{New} to add further operations and enter the values in Fig.~\ref{fig:operation_parameters}.  Parameters can be added by pressing \texttt{Edit} and entering the name and choosing the type of each parameter in a separate dialogue.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.6\textwidth]{pics/memBoxBilder/memBox38.png}
	\caption{Parameters and Return Type.}
	\label{fig:operation_parameters}
\end{figure}
\FloatBarrier

\item[$\blacktriangleright$] Repeat the process for the values in Fig.~\ref{fig:operation_partition}.
The \texttt{Return Type} can be chosen via the drop-down menu for primitives (e.g. \texttt{EBoolean}), or via the \texttt{\ldots} button (indicated in Fig.~\ref{fig:operation_parameters}) for types in the metamodel (e.g. \texttt{Card}).
\end{enumerate}

\vspace{-.5cm}
\begin{quote}
$\textbf{Please note:}$ Non-primitive types \emph{must} be chosen via the \texttt{\ldots} button that allows you to browse for the corresponding elements in your project.
Just typing them unfortunately won't work due to EA API restrictions!
\end{quote}
\vspace{-.5cm}

If you've done everything right, your dialogue should now contain three methods \texttt{check}, \texttt{empty}, and \texttt{removeCard} with corresponding parameters and return types as in Fig.~\ref{fig:operation_partition}.
\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.9\textwidth]{pics/memBoxBilder/memBox39}
	\caption{All operations in \texttt{Partition}.}
	\label{fig:operation_partition}
\end{figure}

Add all operations analogously for \texttt{Box} and \texttt{Card}, so that your metamodel closely resembles Fig.~\ref{fig:metamodel_complete}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.6\textwidth]{pics/memBoxBilder/memBox44}
	\caption[Complete metamodel for our learning box.]{Complete metamodel for our learning box (note that names of method parameters are not displayed by default in EA but are shown here for presentation purposes).}
	\label{fig:metamodel_complete}
\end{figure}

% TODO geaenderte Funktionen (von util weg) beschreiben, util rausnehmen
Lets take a step back and review our metamodel.
We have modelled a \texttt{Box} that contains arbitrary many \texttt{Partition}s.
A \texttt{Partition} in the \texttt{Box} has a \texttt{next} and \texttt{previous} \texttt{Partition} that can be set or not. Finally, \texttt{Partition}s contain \texttt{Card}s.

A \texttt{Box} has a \texttt{name}, and can be extended by calling \texttt{grow}.
A \texttt{Box} can print out its contents via \texttt{toString}.

The main method of the learning box is \texttt{Partition::check} that takes a \texttt{Card} and the user's guess as an \texttt{EString} and returns \texttt{true} or \texttt{false} depending on if the guess was correct or not.

A \texttt{Partition} can also \texttt{empty} itself of all \texttt{Cards}, or \texttt{remove} a particular \texttt{Card}.
Last but not least, a \texttt{Partition} has a \texttt{partitionSize} that can be used to indicate that the \texttt{Partition} is full and is ready to be revised.

A \texttt{Card} contains the actual content to be learnt as a question on the card's \texttt{face} and the answer on the card's \texttt{back}.
A \texttt{Card} also maintains a \texttt{partition\-History} which can be used to keep track of how often a \texttt{Card} has been answered correctly/wrongly.
This might indicate how difficult the \texttt{Card} is for a specific user.
When learning a language, it makes sense to be able to swap the target and source language and this is supported by \texttt{Card} via \texttt{invert} (turns the card around).
% TODO ende von beschreibung

Now try to export the metamodel for code generation in Eclipse (if problems occur during the following steps, we recommend to read section \ref{sect:validating}. This might help you to find your mistakes).

% TODO verweis auf validierung?
\begin{enumerate}
\item[$\blacktriangleright$] To do this right-click on \texttt{LearningBoxLanguage} and choose ``Extensions/MOFLON::Ecore Addin/Export Selection to Workspace''.
Then switch to your Eclipse work\-space and refresh the metamodel workingset.
\end{enumerate}


If you have done everything right, a new project \texttt{LearningBoxLanguage} should be created in the \texttt{Demo} working set in your Eclipse workspace.
If this is not the case please ensure that your metamodel is identical with Fig.~\ref{fig:metamodel_complete}.
If you believe everything is correct and things still don't work then feel free to contact us at \href{mailto:contact@moflon.org}{contact@moflon.org}.
If code is generated successfully, take a look at all the stuff that has been generated under \texttt{/gen}, especially the default  implementation for all methods that just throws an  \texttt{OperationNotSupported} exception.
We shall see later in the tutorial that the EMF codegenerator actually supports injecting hand-written implementations of methods into generated methods and classes.
With eMoflon however, we can also model a large part of the dynamic semantics and only need to implement small helper methods for e.g. string manipulation by hand.

\section{Validating your metamodel}
\label{sect:validating}


Our EA extension provides rudimentary support for validating the static semantics (Ecore) and dynamic semantics (SDM) of metamodels.
Validation results are displayed and, in some cases, even ``quick fixes'' to automatically solve the problems are offered.
Our validation framework is still work in progress so if you find an error that is not/wrongly detected feel free to send us a brief description.

\begin{enumerate}
\item[$\blacktriangleright$] To make the validation output window visible in EA, choose ``Extensions/\-Add-In Windows''.
This should display a new output window as depicted in Fig.~\ref{fig:validation_output}. This control panel also contains shortcuts for all the functionality available via the extensions file menu and many users actually prefer this.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.6\textwidth]{pics/memBoxBilder/memBox40}
	\caption{Activating the validation output window}
	\label{fig:validation_output}
\end{figure}
\FloatBarrier

\item[$\blacktriangleright$] To start the validation choose ``Extensions/\-MOFLON::Ecore Addin/\-Validate all'' in EA (Fig.~\ref{fig:validation_menu}).
If you haven't already made any mistakes while modelling your \texttt{LearningBoxLanguage} in the last chapter, the output should resemble Fig.~\ref{fig:validation_output}, indicating that your metamodels are free of errors (at least according to our validation).

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.6\textwidth]{pics/memBoxBilder/memBox41}
	\caption{Starting the validation}
	\label{fig:validation_menu}
\end{figure}
\FloatBarrier
\end{enumerate}


To get familiar with our validation and quick fix features, let's add two small modelling errors in \texttt{LearningBoxLanguage}.

\begin{enumerate}
\item[$\blacktriangleright$] Create a new class in the \texttt{Learning\-Box\-Language} diagram.
You can retain the default name \texttt{EClass1}.
Let's assume, you wish to delete this class from your metamodel.
\item[$\blacktriangleright$] Select it (\texttt{EClass1}) in the diagram and press the \texttt{Delete} button.
Note that \texttt{EClass1} still exists in the project browser (and thus in your metamodel) and that you have one new \texttt{Information} message in the validation output (Fig.~\ref{fig:validation_information}).

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.7\textwidth]{pics/memBoxBilder/memBox43}
	\caption{Output indicating that an element is present in the metamodel, which is not in any diagram and should probably be deleted completely}
	\label{fig:validation_information}
\end{figure}

The message informs you that \texttt{EClass1} is not on any diagram, and as it is still in the model, that this could be a mistake.
Just pressing the \texttt{Delete} button is apparently not the proper way of \emph{deleting} \texttt{EClass1} from the metamodel and only removes it from the current diagram.
Deleting elements properly and other EA specific aspects are discussed in detail in Chapter~\ref{chap:Tips and Tricks}.


\item[$\blacktriangleright$] To navigate to the problematic element click once on the information message in the output window.
EA should navigate automatically to \texttt{EClass1} and highlight it in the project browser.
\item[$\blacktriangleright$] To check if there are any quick fixes available, double click the information message to invoke the quick fix dialogue.
In this case, there is one quick fix which suggests simply deleting the element from the model (Fig.~\ref{fig:quick-fix1}) as this is probably what was intended.
\item[$\blacktriangleright$] Click \texttt{OK} and \texttt{EClass1} will be deleted correctly from your model.
Your metamodel should now be error-free again as indicated by the validation output window.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.55\textwidth]{pics/memBoxBilder/memBox45}
	\caption{Quick fix for elements that are not on any diagram}
	\label{fig:quick-fix1}
\end{figure}
\FloatBarrier

\item[$\blacktriangleright$] To make an error that leads to a more critical message than ``information'',
double click the navigable reference end \texttt{previous} of the class \texttt{Partition}, and delete its role name as depicted in Fig.~\ref{fig:delete-role-name}.
Affirm with \texttt{OK}.

You should now see a new \texttt{Fatal Error} in the validation output, stating that a navigable end \emph{must} have a role name (Fig.~\ref{fig:fatal-error}).
As navigable references are mapped to data members in a Java class, omitting the name of a navigable reference makes code generation impossible (data members, i.e., class variables must have a name).

\begin{figure}[htbp]
    \centering
  \includegraphics[width=0.85\textwidth]{pics/memBoxBilder/memBox46}
    \caption{Deleting a navigable role name of a reference}
    \label{fig:delete-role-name}
\end{figure}

\item[$\blacktriangleright$] As before, clicking the error message selects the problematic connector in the diagram, and double clicking reveals that there are no quick fixes for this problem (Fig.~\ref{fig:fatal-error}).
\item[$\blacktriangleright$] Correct your metamodel manually by setting the name of the navigable reference back to \texttt{previous}.
\clearpage
\item[$\blacktriangleright$] Ensure that your metamodel closely resembles Fig.~\ref{fig:metamodel_complete} again, and that there are no error messages before you proceed with the rest of the chapter.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.7\textwidth]{pics/memBoxBilder/memBox47}
	\caption{Fatal Error after deleting a navigable role name}
	\label{fig:fatal-error}
\end{figure}
\end{enumerate}

As you've probably already noticed, we distinguish between five different types of validation messages:
\begin{description}
  \item[Information:]~\\
  This is only a hint for the user and can be safely ignored if you know what you're doing.
  Export and code generation should be possible, but certain naming/modelling conventions are violated, or a problematic situation has been detected.
  \item[Warning:]~\\ Export and code generation is possible, but only with defaults and automatic corrections applied by the code generator.
  As this might not be what the user wants, such cases are flagged as warnings (e.g., omitting the multiplicity at references which is automatically set by the code generator to 1).
  Being as explicit as possible is often better than relying on defaults.
  \item[Error:]~\\ Although the metamodel can be exported from EA, it is not Ecore conform and code generation will not be possible.
  \item[Fatal Error:]~\\ The metamodel cannot be exported as required information such as names or classifiers of model elements are incorrectly set or missing.
  \item[Eclipse Error:]~\\ Error messages produced by our Eclipse plugin after an unsuccessful attempt to generate code.
  This is currently not actively used.
   %This will be discussed in detail in Sect~\ref{par:validation_in_eclipse}.

\end{description}

\section{Creating an instance (model)}
\label{sect:instance}

Before diving into modelling dynamic behaviour, let's have a brief look at how to create a concrete \emph{instance model} of your metamodel in Eclipse.
In the following, we use \emph{metamodel} and \emph{instance model} to differentiate between models that represent the abstract syntax and static semantics of a domain specific language (metamodel), and models that are expressed \emph{in} such a language (instance models of the metamodel).
To create an instance model, switch to your Eclipse workspace containing the generated working sets and projects from Sect.~\ref{sec:abstractSyntax}.
EMF provides a generic model editor for free that allows us to create and edit an arbitrary instance of any metamodel specified with eMoflon.

Back in Eclipse, navigate to the \texttt{model} folder in your \texttt{LearningBoxLanguage} project.
Double-click the \texttt{LearningBoxLanguage.ecore} model to invoke  the \emph{Ecore model editor}.
Expand this tree to view the different classes and packages you modelled with EA in Sect.~\ref{sec:abstractSyntax}.
To create a concrete instance of the metamodel, you must select a class which will become the root element of the new instance.
For our example, right-click the class \texttt{Box} and choose \texttt{Create Dynamic Instance\ldots} from the context-menu as depicted in Fig.~\ref{fig:context_menu}.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.7\textwidth]{pics/modelBrowserBilder/createInstance.png}
	\caption{Context menu of Ecore model in Eclipse}
	\label{fig:context_menu}
\end{figure}

A dialogue should pop up asking where instance model file should be persisted.
We suggest saving all your instances in a folder named \texttt{instances} that is created in every new repository project.
This is however just a convention, you are of course free to store your instances anywhere.
Last but not least, enter a name for the instance model (Fig.~\ref{fig:store_dynamic_instance}).

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.6\textwidth]{pics/modelBrowserBilder/persistDialog.png}
	\caption{Dialogue for creating a dynamic model instance}
	\label{fig:store_dynamic_instance}
\end{figure}

Now click \texttt{Finish} and the \emph{generic model editor} should be opened for your instance model.
This editor works just like the Ecore model editor but is ``generic'' as it allows you to create and edit an instance of \emph{any} metamodel not just of Ecore.
You can populate your instance model by adding new children or siblings via a right-click on an element of the instance model to invoke the context-menu depicted in Fig.~\ref{fig:create_instance}.
Note that EMF supports you by respecting your metamodel and reducing the choice of creatable elements to valid types only, depending on the current context.

\begin{figure}[htbp]
	\centering
  \includegraphics[width=0.95\textwidth]{pics/modelBrowserBilder/adjustModel.png}
	\caption{Context menu for creating model elements}
	\label{fig:create_instance}
\end{figure}

You can save your model as an XMI file by pressing \texttt{Ctrl+S}.
The model can be reloaded via a simple double-click to invoke the generic model editor.

That's all for the ``static part" of our metamodel. Let's move on and model the dynamic behaviour of our learning box!

