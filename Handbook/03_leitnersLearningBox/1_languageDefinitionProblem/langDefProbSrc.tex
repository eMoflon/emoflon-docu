
\section{A language definition problem?}

As in any area of study, metamodelling has its fair share of buzz words used by experts to communicate concisely.  Although some concepts might seem quite abstract for a beginner, a well defined vocabulary is important so we know
exactly what we are talking about.

The first step is understanding that metamodelling equates to language definition.
This means that the task of building a system like our learning box can be viewed as defining a suitable language that can be used to describe the system.
This language oriented approach has a lot of advantages including a natural support for product lines (individual products are valid members of the language) and a clear separation between platform independent and platform specific details.

So what constitutes a language?  The first question is obviously what the building blocks of your language ``look'' like.
Will your language be textual?  Visual?  This representation referred to as the \emph{Concrete Syntax}\marginpar{\emph{Concrete Syntax}} of a language and is basically an interface to end users who use the language. In the case of our learning box, figure~\ref{fig:membox_illustration} can be viewed as a possible concrete syntax.
As we are building a learning box as a software system however, our actual concrete syntax  will probably be composed of GUI elements like buttons, drop-down menus and text fields.

Irrespective of what a language looks like, members of the language must adhere to the same set of ``rules''.
\marginpar{\emph{Grammar}}
\marginpar{\emph{Graph Grammar}}
For a natural language like English, this set of rules is usually called a \emph{grammar}.
\marginpar{\emph{Type Graph}}
In metamodelling, however, everything is represented as a graph of some kind and, although the concept of a  \emph{graph grammar} is also quite well-spread and understood, metamodellers  more often use a \emph{type graph} that defines what types and relations  constitute a language.

A graph that is a member of your language must \emph{conform to} the corresponding type graph for the language.
To be more precise, it must be possible to type the graph according to the type graph - the types and relations used in the graph must exist in the type graph and not contradict the structure defined there.
\marginpar{\emph{Abstract Syntax}}
This way of defining membership to a language has many parallels to the class-object relationship in the object-oriented paradigm and should seem very familiar for any programmer used to OO.
This type graph is referred to as the \emph{Abstract Syntax} of a language.

Often, one might want to further constrain a language, beyond simple typing rules.
\marginpar{\emph{Static \\ Semantics}}
This can be accomplished with a further set of rules or constraints that members of the language must fulfil in addition to being conform to the type graph.
These further constraints are referred to as the \emph{Static Semantics} of a language.

With these few basic concepts, we can now introduce a further and central concept in metamodelling, the \emph{metamodel}, which is basically a simple class diagram. \marginpar{\emph{Metamodel}}
A metamodel defines not only the abstract syntax of a language but also some basic constraints (a part of the static semantics).

In analogy to the ``everything is an object'' principle in the Object Oriented (OO) paradigm, in metamodelling, everything is a model! \marginpar{\emph{Unification}} This principle is called \emph{Unification} and has many advantages. If everything is a model, a metamodel that defines (at least a part of) a language must be a model itself.
\marginpar{\emph{Meta-metamodel}}
\marginpar{\emph{Meta-Language}}
\marginpar{\emph{Modelling Language}}
This means that it conforms to some \emph{meta-metamodel} which in turn defines a \emph{(meta)modelling language} or \emph{meta-language}.
For metamodelling with eMoflon, we support \emph{Ecore} as a modelling language and it defines types like \texttt{EClass} and \texttt{EReference}, which we will be using to specify  our metamodels.
Alternate modelling languages include MOF, UML and Kermeta.

Thinking back to our learning box, we can define the types and relations we want to allow. We want an entire box of flashcards where each card is contained within a partition, and each partition is contained within the box. Multiplicities are an example of static constraints that do not belong to the abstract syntax, but can nonetheless be expressed in a metamodel.
An example could be that a card can only ever exist in one partition, or that a partition can have either one \texttt{next} partition, or none at all.

\pagebreak
More complex constraints that cannot be expressed in a metamodel are usually specified using an extra \emph{constraint language}\marginpar{\emph{Constraint Language}} such as the Object Constraint Language (OCL). This idea, however,  is beyond the scope of this handbook. We'll stick to metamodels without needeing an extra contstraint language. 

$\textbf{A short recap:}$  
We have learned that metamodelling starts with defining a suitable language.
For the moment, we know that a language comprises a concrete syntax (how the language ``looks''),  an abstract syntax (types and relations of the underlying graph structure), and static semantics (further constraints that members of the language must fulfil).
Metamodels are used to define the abstract syntax, and a part of the static semantics of a language, while \emph{models} are graphs that conform to some
\marginpar{\emph{Model}}
metamodel (which can be typed according to the abstract syntax and must adhere to the static semantics).

This handbook is meant to be hands-on, so enough theory!
Lets define, step-by-step, a metamodel for a learning box using our tool, eMoflon. From the links below, select one to follow the language syntax you'd like to learn.

\vspace{1cm}

\begin{itemize}
  \item[$\triangleright$] {\bf Section~\ref{sec:staticAbstract}} A visual language defintion; Modeling with Diagrams
  \item[$\triangleright$] {\bf Section~\ref{sec:staticConcrete}} A textual language defintion: Modeling with MOSL
\end{itemize}