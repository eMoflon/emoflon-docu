\newpage
\section{Text-to-Tree transformation}
\genHeader

Some sort of nice seque..

As we shall see in a moment, libraries and shelves correspond to a folder structure while the contents for a single dictionary are specified in a file.
Figure \ref{fig:moca-4-Tokens} depicts a small sample of the textual syntax used to specify a dictionary. 

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.7\textwidth]{4-tokens}
  \caption{Identified tokens in a dictionary file}
  \label{fig:moca-4-Tokens}
\end{center}
\end{figure}

On the way to an instance model of our dictionary metamodel, the very first step is to create nice \emph{chunks} of characters. This step is called
\emph{lexing} and it simplifies the actual comprehension of the complete text. Interestingly human beings actually comprehend text in a similar manner, one
recognizes whole words without ``seeing'' every individual character. This is the reason why you can siltl raed tihs sneentce alsomt eforftlsesly. A lexer
recognizes these chunks or \emph{tokens} and passes them on as a token stream to the \emph{parser} that does the actual work of recognizing complex
hierarchical and recursive structures.
   
To recognize the tokens as indicated in Fig.~\ref{fig:moca-4-Tokens}, \texttt{ANTLR} can automatically generate a lexer in Java from a compact specification.
This is actually a DSL for lexing and is explained in detail in \cite{ANTLR}. If you are unfamiliar with EBNF, and have feel you may have problems understanding
the lexer grammar, we suggest going through the documentation on on \url{www.antlr.org}, or reading the relevant chapters in \cite{ANTLR}. Otherwise, let's
complete the \emph{lexer} and \emph{parser} grammars that will handle our project instances.

\begin{itemize}
  
\item[$\blacktriangleright$] Navigate to ``Diction\-ary\-Code\-Adap\-ter/src/org.moflon.moca.dict\-ion\-ary\-.pars\-er" and edit \texttt{DictionaryLexer.g}
until it closely resembles Fig.~\ref{eclipse:dictionaryLexer}. Don't forget to add \texttt{import org.moflon.moca.MocaUtil} to \texttt{@header}, and be vigilant
to avoid any typos and mistakes! Save to compile the file, and ensure no errors persist before proceeding.

\end{itemize}
\newpage

\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=0.7\textwidth]{eclipse_dictionaryLexer}
  \caption{Lexer grammar}
  \label{eclipse:dictionaryLexer}
\end{center}
\end{figure}

With this lexer, we can now form its stream of tokens into a \emph{tree}. In this context, a \emph{tree} is an acyclic, hierarchical, recursive structure (as
depicted in Fig.~\ref{eclipse:dictLexer}). Depending on what the tree is to be used for, it can be organized much differently with extra \emph{structural} nodes
such as \texttt{DICTIONARY} or \texttt{ENTRY} which were not present in the textual syntax. These can be used to give additional meaning to the tree.

\begin{figure}[htp]
\begin{center}
 \includegraphics[width=\textwidth]{5-tree}
  \caption{MocaTree structure}
  \label{eclipse:dictLexer}
\end{center}
\end{figure}

\begin{itemize}

\item[$\blacktriangleright$] Open and edit \texttt{DictionaryParser.g} until it closely resembles Fig.~\ref{eclipse:dictParser}. As with the lexer, avoid any
mistakes, and ensure it compiles before proceeding.

\end{itemize}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.9\textwidth]{eclipse_dictionaryParser}
  \caption{Parser grammar}
  \label{eclipse:dictParser}
\end{center}
\end{figure}

\newpage

You'll notice that the parser grammar is extremely similar to the lexer grammar, save for some \emph{parser actions} following the \texttt{`->'} symbol. These
actions order the construction of the tree. Using this simple tree language, one can (1) abstract from tokens like \texttt{`\{'} or \texttt{`\}'}, which are
just \emph{syntactical noise}\footnote{Irrelevant content for our model.} and (2) enrich the tree with structural nodes like \texttt{ENTRY}, which add explicit
structure to the tree. Refer to \cite{ANTLR} and online resources for detailed explanations on the syntax and semantics of the parser grammar supported by
\texttt{ANTLR}.

\begin{itemize}


\item[$\blacktriangleright$] Before taking our lexer and parser out for a spin, navigate to ``src/org.moflon.tie" and open \texttt{TGGMain.java}. If everything
has gone well, it should resemble Fig.~\ref{eclipse:defaultTGGMain}.

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=\textwidth]{eclipse_TGGMainDefault}
  \caption{The TGG driver method}
  \label{eclipse:defaultTGGMain}
\end{center}
\end{figure}

\end{itemize}

You can see that this main method is essentially the driver for the transformation, executing each of the four stages of a full forward and backwards
transformation. In a nutshell, each folder in \texttt{instances/in/myLibrary} is taken as a root of a tree, and their folder and file structures are reflected
as a hierarchy of (children) nodes in the tree. For each file, the framework searches for a registered parser that is responsible for the particular file,
passes the content on to the parser and plugs in the tree from the parser as a single subtree of the corresponding file node in the overall tree.

\begin{itemize}

\item[$\blacktriangleright$] Comment out line 45, which calls the unparser to generate an output directory structure. We will define this model-to-text unparser
a bit later. 

\newpage

\item[$\blacktriangleright$] The final step is now to prepare some input for the framework. Navigate to ``DictionaryCodeAdapter/instances/in'' and create the
filesystem depicted in Fig.~\ref{eclipse:textDirectory}. 

\vspace{1cm}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=0.5\textwidth]{inputData}
  \caption{Input directory structure}
  \label{eclipse:textDirectory}
\end{center}
\end{figure}

\vspace{1cm}

\item[$\blacktriangleright$] Next, Complete each of the four \texttt{.dictionary} files with the contents in Table~\ref{moca-inputdata}.\footnote{Please do not
copy and paste this data as it your .pdf reader may add some invisible characters to the file that MOSL will not detect} Be sure that there are no mistakes with
elements such as colons or commas! Parsing will not succeed if the files do not perfectly conform to the lexer. 

\end{itemize}

As you can see, this setup creates a single library split into two languages, each containing unique dictionaries. Reviewing
Fig.~\ref{eclipse:dictParser}, you can see that the structure of these files conform to the parser's \texttt{main} command: it first lists the dictionary's
\texttt{title}, may or may not contain a \texttt{author}, and contains all \texttt{entry} elements between the \texttt{OPEN} and \texttt{CLOSE} brackets.

\newpage
\begin{table}

\begin{tabular}{p{6cm} p{6cm} }
\footnotesize
\textbf{english/numbers1-10.dictionary:}
\begin{verbatim}
title: "numbers1-10"
email: "contact@langenscheidt.de"	
{
  "null : zero", beginner
  "eins : one", beginner
  "zwei : two", beginner
  "drei : three", beginner
  "vier : four", beginner
  "fuenf : five", beginner
  "sechs : six", beginner
  "sieben : seven", beginner
  "acht : eight", beginner
  "neun : nine", beginner
  "zehn : ten", beginner 
}
\end{verbatim} 

\vspace{0.5cm}

\footnotesize
\textbf{french/numbers11-20.dictionary:}
\begin{verbatim}
title: "numbers11-20"
email: "contact@pons.de"	
{
  "elf : onze", advanced
  "zwoelf : douze", advanced
  "dreizehn : treize", advanced
  "vierzehn : quatorze", advanced
  "fuenfzehn : quinze", advanced
  "sechzehn : seize", master
  "siebzehn : dix-sept", master
  "achtzehn : dix-huit", master
  "neunzehn : dix-neuf", master
  "zwanzig : vingt", master
}
\end{verbatim}
&

\footnotesize
\textbf{french/numbers1-10.dictionary:}
\begin{verbatim}   
title: "numbers1-10"
email: "contact@pons.de"	
{
  "null : zero", beginner
  "eins : un/une", beginner
  "zwei : deux", beginner
  "drei : trois", beginner
  "vier : quatre", beginner
  "fuenf : cinq", beginner
  "sechs : six", beginner
  "sieben : sept", beginner
  "acht : huit", beginner
  "neun : neuf", beginner
  "zehn : dix", beginner 
}
\end{verbatim}

\vspace{0.5cm}

\footnotesize
\textbf{french/unknown.dictionary:}
\begin{verbatim}
title: "unknown"
{
	"unbekannt : unknown", beginner
}
\end{verbatim}
  \\
\end{tabular}   
\caption{Four input \texttt{.dictionary} files}
\label{moca-inputdata}

\end{table}
\clearpage

\begin{enumerate} 

\item[$\blacktriangleright$] Once you have saved each file, right click on \texttt{TGGMain} and navigate to ``Run As/Java Application'' to run the
transformation, then refresh the \texttt{instances} folder. Despite being primarily unimplemented, it still executed and generated several files
(Fig.~\ref{eclipse:postParse}).

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.4\textwidth]{eclipse_explorerPostGeneration}
  \caption{Result of the first TGG execution}
  \label{eclipse:postParse}
\end{center}
\end{figure} 

\item[$\blacktriangleright$] To explain, \texttt{tree.xmi} is the model generated directly from your \texttt{myLibrary} filesystem input. In fact, this is the
result of the first step in the forward transformation, from text-to-tree!

\item[$\blacktriangleright$] \texttt{tree.xmi\_FWD.xmi} is the \texttt{Dictionary} result of the complete forward transformation. This second step, from
tree-to-model also produced \texttt{corrFWD.xmi} and \texttt{protocol\_FWD.xmi}. Given that we haven't actually specified any rules yet, the model is simply an
incomplete output container.

\clearpage

\item[$\blacktriangleright$] Similarly first step in the  backwards transformation generated \texttt{corrBWD.xmi}, \texttt{protocolBWD.xmi}, and
\texttt{tree.xmi\_FWD.xmi\_BWD.xmi}. Ideally, this file will resemble the original \texttt{tree.xmi} without loss of information. The final, tree-to-model files
can't yet be found as we commented out the unparsing command that would have generated this.

\item[$\blacktriangleright$] Open \texttt{tree.xmi} and compare the contents to Fig.~\ref{eclipse:treeResult}. Reflect on the directory-type structure of the
tree, where each \texttt{File} and its contents appear as \texttt{Node}s. This file is important to understand; The filesystem was transformed into a
corresponding hierarchy of \texttt{Folders} and \texttt{Files}. The actual \emph{text} content of each file is then transformed to a subtree using a registered,
suitable parser. The resulting subtree from the parser is then connected to the existing tree by setting its \texttt{DICTIONARY} root as the single child node
of a \texttt{File}.

\end{enumerate}

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.6\textwidth]{eclipse_textParsingGeneration}
  \caption{MocaTree created by the framework using our parser}
  \label{eclipse:treeResult}
\end{center}
\end{figure}

\vspace{0.5cm}

If everything has executed without error, well done! To complete this forward transformation, we need to specify some TGG rules.
