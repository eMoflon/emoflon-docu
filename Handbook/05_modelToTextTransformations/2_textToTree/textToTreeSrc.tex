\newpage
\section{Text-to-tree transformation}
\genHeader

Let's discuss how the transformation will proceed. For reference, Fig.~\ref{fig:moca-4-Tokens} depicts a small sample of the textual syntax that will specify
a dictionary instance. As we shall see in a moment, the libraries and shelves containing each dictionary correspond to a folder structure, while the
contents for a single dictionary are specified in a file.

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.7\textwidth]{4-tokens}
  \caption{Identified tokens in a dictionary file}
  \label{fig:moca-4-Tokens}
\end{center}
\end{figure}

On the way to an instance model of our dictionary metamodel, the very first step is to create nice \emph{chunks} of characters. This step is called
\emph{lexing} and it simplifies the actual comprehension of the complete text. Interestingly, human beings actually comprehend text in a similar manner; one
recognizes whole words without ``seeing'' every individual character. This is the reason why you can siltl raed tihs sneentce alsomt eforftlsesly. A lexer
recognizes these chunks or \emph{tokens} and passes them on as a token stream to the \emph{parser} that does the actual work of recognizing complex
hierarchical and recursive structures.
   
To recognize the tokens as indicated in Fig.~\ref{fig:moca-4-Tokens}, \texttt{ANTLR} can automatically generate a lexer in Java from a compact specification.
This is actually a DSL for lexing and is explained in detail in \cite{ANTLR}. If you are unfamiliar with EBNF, and feel you may have problems understanding
the lexer grammar, we suggest going through the documentation on \url{www.antlr.org}, or reading the relevant chapters in \cite{ANTLR}. Otherwise, let's
complete the \emph{lexer} and \emph{parser} grammars that will handle our project instances.

\begin{itemize}
  
\item[$\blacktriangleright$] Navigate to ``Diction\-ary\-Code\-Adap\-ter/src/org.moflon.moca.dict\-ion\-ary\-.pars\-er" and edit \texttt{DictionaryLexer.g}
until it matches Fig.~\ref{eclipse:dictionaryLexer}. 


\newpage

\begin{figure}[!htbp]
\begin{center}
  \includegraphics[width=0.7\textwidth]{eclipse_dictionaryLexer}
  \caption{Lexer grammar}
  \label{eclipse:dictionaryLexer}
\end{center}
\end{figure}

\item[$\blacktriangleright$] Don't forget to add \texttt{import org.moflon.moca.MocaUtil} to \texttt{@header}. Be vigilant to avoid any typos and mistakes!

\item[$\blacktriangleright$] Save to compile the file, and ensure no errors persist before proceeding.

\end{itemize}

With a parser, we can now form a file's stream of tokens created by the lexer into a \emph{tree}. In this context, a \emph{tree} is an acyclic, hierarchical,
recursive structure (as depicted in Fig.~\ref{eclipse:dictLexer}). Depending on what the tree is to be used for, it can be organized differently using extra
\emph{structural} nodes such as \texttt{DICTIONARY} or \texttt{ENTRY} which were not present in the textual syntax. These can be used to give additional
meaning to the tree.

\begin{figure}[htp]
\begin{center}
 \includegraphics[width=\textwidth]{5-tree}
  \caption{Abstract Syntax Tree (AST) representation of an input token stream}
  \label{eclipse:dictLexer}
\end{center}
\end{figure}

\begin{itemize}

\item[$\blacktriangleright$] Open and edit \texttt{DictionaryParser.g} (in the same package) until it matches Fig.~\ref{eclipse:dictParser}. As with
the lexer, avoid any mistakes, and ensure it compiles before proceeding.

\end{itemize}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.9\textwidth]{eclipse_dictionaryParser}
  \caption{Parser grammar}
  \label{eclipse:dictParser}
\end{center}
\end{figure}

\newpage

You'll notice that the parser grammar is extremely similar to the lexer grammar, save for some \emph{parser actions} following the \texttt{`->'} symbol. These
actions control the construction of the resulting tree. Using this simple tree language, one can (1) abstract from tokens like \texttt{`\{'} or \texttt{`\}'},
which are just \emph{syntactical noise}\footnote{Irrelevant content for our model} and (2) enrich the tree with structural nodes such as \texttt{ENTRY}, which
add explicit structure to the tree. Refer to \cite{ANTLR} and online resources for detailed explanations on the syntax and semantics of the parser grammar
supported by \texttt{ANTLR}.

\begin{itemize}


\item[$\blacktriangleright$] Before taking our lexer and parser for a spin, navigate to \\ ``src/org.moflon.tie" and open \texttt{TGGMain.java}
(Fig.~\ref{eclipse:defaultTGGMain}).

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=\textwidth]{eclipse_TGGMainDefault}
  \caption{The TGG driver method}
  \label{eclipse:defaultTGGMain}
\end{center}
\end{figure}

\end{itemize}

You can see that this main method is essentially the driver for the transformation, executing each of the four stages of a full forward and backwards
transformation. In a nutshell, each folder in \texttt{instances/in/myLibrary} is taken as the root of a tree, and their folder and file structures are reflected
as a hierarchy of (children) nodes in the tree. For each file, the framework searches for a registered parser that is responsible for the particular file,
passes the content on to the parser and plugs in the tree from the parser as a single subtree of the corresponding file node in the overall tree.

\begin{itemize}

% \item[$\blacktriangleright$] Comment out line 45, which calls the unparser to generate an output directory structure. This command is unnecessary at this
% point as we intend to define this ``reverse" model-to-text unparser a bit later. 

\newpage

\item[$\blacktriangleright$] To prepare some input for the framework, navigate to ``DictionaryCodeAdapter/instances/in'' and create the
filesystem depicted in Fig.~\ref{eclipse:textDirectory}. 

\vspace{1cm}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=0.5\textwidth]{inputData}
  \caption{Input directory structure}
  \label{eclipse:textDirectory}
\end{center}
\end{figure}

\vspace{1cm}

\item[$\blacktriangleright$] Complete each of the four \texttt{.dictionary} files with the contents in Table~\ref{moca-inputdata}.\footnote{If you copy and
paste this data, be careful as your .pdf reader may add some invisible characters to the file that ANTLR will not detect and ignore as white space.} Be sure
that there are no mistakes with symbols such as colons or commas!

\end{itemize}

As you can see, the input is structured as a single library, \texttt{myLibrary}, and split into two languages, english and french, each containing
some dictionaries. Reviewing Fig.~\ref{eclipse:dictParser}, you can see that the structure of these files conforms to the parser's \texttt{main} rule: it
first lists the dictionary's \texttt{title}, may or may not contain an \texttt{author}, and contains all \texttt{entry} elements between a pair of \texttt{OPEN}
and \texttt{CLOSE} brackets.

\newpage
\begin{table}

\begin{tabular}{p{6cm} p{6cm} }
\footnotesize
\textbf{english/numbers1-10.dictionary:}
\begin{verbatim}
title: "numbers1-10"
email: "contact@langenscheidt.de"	
{
  "null : zero", beginner
  "eins : one", beginner
  "zwei : two", beginner
  "drei : three", beginner
  "vier : four", beginner
  "fuenf : five", beginner
  "sechs : six", beginner
  "sieben : seven", beginner
  "acht : eight", beginner
  "neun : nine", beginner
  "zehn : ten", beginner 
}
\end{verbatim} 

\vspace{0.5cm}

\footnotesize
\textbf{french/numbers11-20.dictionary:}
\begin{verbatim}
title: "numbers11-20"
email: "contact@pons.de"	
{
  "elf : onze", advanced
  "zwoelf : douze", advanced
  "dreizehn : treize", advanced
  "vierzehn : quatorze", advanced
  "fuenfzehn : quinze", advanced
  "sechzehn : seize", master
  "siebzehn : dix-sept", master
  "achtzehn : dix-huit", master
  "neunzehn : dix-neuf", master
  "zwanzig : vingt", master
}
\end{verbatim}
&

\footnotesize
\textbf{french/numbers1-10.dictionary:}
\begin{verbatim}   
title: "numbers1-10"
email: "contact@pons.de"	
{
  "null : zero", beginner
  "eins : un/une", beginner
  "zwei : deux", beginner
  "drei : trois", beginner
  "vier : quatre", beginner
  "fuenf : cinq", beginner
  "sechs : six", beginner
  "sieben : sept", beginner
  "acht : huit", beginner
  "neun : neuf", beginner
  "zehn : dix", beginner 
}
\end{verbatim}

\vspace{0.5cm}

\footnotesize
\textbf{french/unknown.dictionary:}
\begin{verbatim}
title: "unknown"
{
	"unbekannt : unknown", beginner
}
\end{verbatim}
  \\
\end{tabular}   
\caption{Four input \texttt{.dictionary} files}
\label{moca-inputdata}

\end{table}
\clearpage

\begin{itemize} 

\item[$\blacktriangleright$] Once you have saved each file, right click on \texttt{TGGMain} and navigate to ``Run As/Java Application'' to run the
transformation.

\item[$\blacktriangleright$] Refresh the \texttt{instances} folder. Despite being (mostly) unimplemented, the TGG still executed, generating several files in
the process (Fig.~\ref{eclipse:postParse}).

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.4\textwidth]{eclipse_explorerPostGeneration}
  \caption{Result of the first TGG execution \update -- unparser}
  \label{eclipse:postParse}
\end{center}
\end{figure} 

\end{itemize}

Let's go over what each of these files are. First, \texttt{tree.xmi} is the direct result of the \texttt{my\-Lib\-rary} filesystem input, which was parsed into
a \texttt{MocaTree} instance by our ANTLR parser. 

While the parser is the only implemented piece of our transformation, TGGMain still used \texttt{tree.xmi} in a forward transformation, producing
the correspondence model \texttt{corrFWD.xmi} (paired with \texttt{protocol\_FWD.xmi}), and the (currently empty) \texttt{Dictionary} target result,
\texttt{tree.xmi\_FWD.xmi}.

\clearpage

The TGG also executed in the inverse direction; \texttt{tree.xmi\_FWD.xmi} was used in the backwards direction, producing \texttt{corrBWD.xmi} (with
\texttt{proto\-col\-\_BWD\-.xmi}) and \texttt{tree.xmi\_FWD.xmi\_BWD.xmi}. 

% We removed the command to do so, but ANTLR will later attempt to unparse this model,
% which, if our TGG transformation was successful, will be identical to the input filesystem. In the meantime, we'll be able to compare this final tree to the
% original \texttt{tree.xmi} to determine accuracy.

\begin{itemize}

\item[$\blacktriangleright$] Open \texttt{tree.xmi} and compare the contents to Fig.~\ref{eclipse:treeResult}. Reflect on the directory-type structure of the
tree, where each \texttt{File} and its contents appear as \texttt{Node}s. This file is important to understand -- The filesystem was transformed into a
corresponding hierarchy of \texttt{Folders} and \texttt{Files}. The actual \emph{text} content of each file is then transformed to a subtree using a registered,
suitable parser. The resulting subtree from the parser is then connected to the existing tree by setting its \texttt{DICTIONARY} root as the single child node
of a \texttt{File}.

\end{itemize}

\vspace{0.5cm}

\begin{figure}[!htbp]
\begin{center}
 \includegraphics[width=0.6\textwidth]{eclipse_textParsingGeneration}
  \caption{A \texttt{MocaTree} created by the framework using our parser}
  \label{eclipse:treeResult}
\end{center}
\end{figure}

\vspace{0.5cm}

If everything has executed without errors, well done! Let's continue with the forward direction (to get a \texttt{Dictionary} instance) by specifiying some
TGG rules.
